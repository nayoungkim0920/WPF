using System.Diagnostics;
using System.IO;
using System.Runtime.CompilerServices;
using System.Text;
using System.Windows;
using System.Windows.Controls;
using System.Windows.Data;
using System.Windows.Documents;
using System.Windows.Input;
using System.Windows.Media;
using System.Windows.Media.Imaging;
using System.Windows.Navigation;
using System.Windows.Shapes;

namespace WpfApp2
{
    /// <summary>
    /// Interaction logic for MainWindow.xaml
    /// </summary>
    public partial class MainWindow : Window
    {
        public MainWindow()
        {
            InitializeComponent();

            // 로딩 패널을 숨김
            LoadingPanel.Visibility = Visibility.Collapsed;

            // 그레이스케일 버튼 비활성화
            GrayScaleButton.IsEnabled = false;
            // 캐니엣지 버튼 비활성화
            CannyEdgeButton.IsEnabled = false;
            // 욜로v5 버튼 비활성화
            YoloV5Button.IsEnabled = false;
        }

        private void OpenImage_Click(object sender, RoutedEventArgs e)
        {
            var openFileDialog = new Microsoft.Win32.OpenFileDialog
            {
                Filter = "Image Files|*.jpg;*.jpeg;*.png;*.bmp",
                Title = "이미지 파일 선택"
            };

            if(openFileDialog.ShowDialog() == true )
            {
                try
                {
                    var bitmapImage = new BitmapImage();
                    bitmapImage.BeginInit();
                    bitmapImage.CacheOption = BitmapCacheOption.OnLoad; // 메모리에 완전히 로드
                    bitmapImage.UriSource = new Uri(openFileDialog.FileName);
                    bitmapImage.EndInit();
                    bitmapImage.Freeze(); // 스레드 안전성을 위해 고정
                    ImageView.Source = bitmapImage;

                    // 그레이스케일 버튼 활성화
                    GrayScaleButton.IsEnabled = true;

                    // 상태표시줄에 파일경로 출력
                    FilePathTextBlock.Text = openFileDialog.FileName;
                }
                catch (Exception ex)
                {
                    MessageBox.Show($"이미지를 로드하는 중 오류가 발생했습니다: {ex.Message}",
                        "오류", MessageBoxButton.OK, MessageBoxImage.Error);
                }
            }
        }

        private async void GrayScale_Click(object sender, RoutedEventArgs e)
        {
            if (ImageView.Source is BitmapImage bitmapImage)
            {
                try
                {
                    // 처리중 보이기
                    LoadingPanel.Visibility = Visibility.Visible;

                    WriteableBitmap writeableBitmap = null;
                    int width = 0, height = 0;

                    // UI 스레드에서 WriteableBitmap 생성 및 크기 가져오기
                    Application.Current.Dispatcher.Invoke(() =>
                    {
                        writeableBitmap = new WriteableBitmap(bitmapImage);
                        width = writeableBitmap.PixelWidth;
                        height = writeableBitmap.PixelHeight;
                    });

                    if (writeableBitmap == null || width == 0 || height == 0)
                        throw new InvalidOperationException("WriteableBitmap이 유효하지 않습니다.");

                    // 시작 시간 기록
                    var startTime = DateTime.Now;

                    // 비동기적으로 그레이스케일 변환
                    await Task.Run(() => ConvertToGrayScale(writeableBitmap, width, height, startTime));

                    // UI 스레드에서 WriteableBitmap 업데이트
                    Application.Current.Dispatcher.Invoke(() =>
                    {
                        writeableBitmap.Freeze();
                        ImageView.Source = writeableBitmap;
                    });
                }
                catch (Exception ex)
                {
                    MessageBox.Show($"이미지를 그레이스케일로 변환하는 중 오류가 발생했습니다: {ex.Message}",
                        "오류", MessageBoxButton.OK, MessageBoxImage.Error);
                }
                finally
                {
                    // 처리중 숨기기
                    LoadingPanel.Visibility = Visibility.Collapsed;

                    // 그레이스케일 버튼 비활성화
                    GrayScaleButton.IsEnabled = false;
                    // 캐니엣지 버튼 활성화
                    CannyEdgeButton.IsEnabled = true;
                }
            }
            else
            {
                MessageBox.Show("이미지가 로드되지 않았습니다.", "오류", MessageBoxButton.OK, MessageBoxImage.Error);
            }
        }

        private void ConvertToGrayScale(WriteableBitmap writeableBitmap, int width, int height, DateTime startTime)
        {
            var pixelData = new byte[width * height * 4];

            // UI 스레드에서 픽셀 데이터를 복사
            Application.Current.Dispatcher.Invoke(() =>
            {
                writeableBitmap.CopyPixels(pixelData, width * 4, 0);
            });            

            Parallel.For(0, height, y =>
            {
                for (int x = 0; x < width; x++)
                {
                    int pixelIndex = (y * width + x) * 4;
                    byte a = pixelData[pixelIndex + 3];
                    byte r = pixelData[pixelIndex + 2];
                    byte g = pixelData[pixelIndex + 1];
                    byte b = pixelData[pixelIndex];

                    byte gray = (byte)(0.3 * r + 0.59 * g + 0.11 * b);

                    pixelData[pixelIndex + 3] = a;    // Alpha
                    pixelData[pixelIndex + 2] = gray; // Red
                    pixelData[pixelIndex + 1] = gray; // Green
                    pixelData[pixelIndex] = gray;     // Blue
                }

                // 처리된 시간 계산
                //var elapsedTime = DateTime.Now - startTime;
                //var processedRows = y + 1; // 현재 처리된 줄
                //var totalRows = height;
                //var processingSpeed = (processedRows / elapsedTime.TotalSeconds).ToString("F2"); // 초당 처리된 줄 수

                // UI 스레드에서 상태 표시줄에 처리 속도 업데이트
                //Application.Current.Dispatcher.Invoke(() =>
                //{
                //    ProcessTimeTextBlock.Text = $"처리 중: {processedRows}/{totalRows} 줄, 속도: {processingSpeed} 줄/초";
                //});
            });

            // 최종 처리 시간 계산
            var totalElapsedTime = DateTime.Now - startTime;


            // UI 스레드에서 픽셀 데이터를 다시 씀
            Application.Current.Dispatcher.Invoke(() =>
            {
                writeableBitmap.Lock();
                writeableBitmap.WritePixels(new Int32Rect(0, 0, width, height), pixelData, width * 4, 0);
                writeableBitmap.Unlock();

                ProcessTimeTextBlock.Text = $"그레이스케일 처리 시간: {totalElapsedTime.TotalSeconds:F2}초";
            });            
        }

        private async void CannyEdge_Click(object sender, RoutedEventArgs e)
        {
            if (ImageView.Source is WriteableBitmap writeableBitmap)
            {
                try
                {
                    // 처리중 보이기
                    LoadingPanel.Visibility = Visibility.Visible;

                    WriteableBitmap writeableBitmap1 = null;
                    int width = 0, height = 0;

                    // UI 스레드에서 WriteableBitmap 생성 및 크기 가져오기
                    Application.Current.Dispatcher.Invoke(() =>
                    {
                        writeableBitmap1= new WriteableBitmap(writeableBitmap);
                        width = writeableBitmap.PixelWidth;
                        height = writeableBitmap.PixelHeight;
                    });


                    if (writeableBitmap1 == null || width == 0 || height == 0)
                        throw new InvalidOperationException("WriteableBitmap이 유효하지 않습니다.");

                    // 시작 시간 기록
                    var startTime = DateTime.Now;

                    await Task.Run(() => ApplyCannyEdgeDetection(writeableBitmap1, width, height, startTime));

                    // UI 스레드에서 WriteableBitmap 업데이트
                    Application.Current.Dispatcher.Invoke(() =>
                    {
                        writeableBitmap1.Freeze();
                        ImageView.Source = writeableBitmap1;
                    });
                }
                catch (Exception ex)
                {
                    MessageBox.Show($"캐니 엣지 검출 중 오류가 발생했습니다: {ex.Message}",
                        "오류", MessageBoxButton.OK, MessageBoxImage.Error);
                }
                finally
                {
                    // 처리중 숨기기
                    LoadingPanel.Visibility = Visibility.Collapsed;

                    // 그레이스케일 버튼 비활성화
                    GrayScaleButton.IsEnabled = false;
                    // 캐니엣지 버튼 비활성화
                    CannyEdgeButton.IsEnabled = false;
                    // 욜로v5 버튼 활성화
                    YoloV5Button.IsEnabled = true;
                }
            }
            else
            {
                MessageBox.Show("그레이스케일 이미지가 필요합니다.", "오류", MessageBoxButton.OK, MessageBoxImage.Error);
            }
        }

        private void ApplyCannyEdgeDetection(WriteableBitmap writeableBitmap, int width, int height, DateTime startTime)
        {
            var pixelData = new byte[width * height * 4];

            // UI 스레드에서 픽셀 데이터를 복사
            Application.Current.Dispatcher.Invoke(() =>
            {
                writeableBitmap.CopyPixels(pixelData, width * 4, 0);
            });

            // 간단한 캐니 엣지 알고리즘 (Sobel Gradient + Thresholding)
            var gradientData = new byte[width * height];

            int[] gx = { -1, 0, 1, -2, 0, 2, -1, 0, 1 };
            int[] gy = { -1, -2, -1, 0, 0, 0, 1, 2, 1 };

            Parallel.For(1, height - 1, y =>
            {
                for (int x = 1; x < width - 1; x++)
                {
                    int pixelIndex = (y * width + x) * 4;
                    double gradX = 0;
                    double gradY = 0;

                    for (int ky = -1; ky <= 1; ky++)
                    {
                        for (int kx = -1; kx <= 1; kx++)
                        {
                            int neighborIndex = ((y + ky) * width + (x + kx)) * 4;
                            byte intensity = pixelData[neighborIndex];
                            gradX += intensity * gx[(ky + 1) * 3 + (kx + 1)];
                            gradY += intensity * gy[(ky + 1) * 3 + (kx + 1)];
                        }
                    }

                    double gradientMagnitude = Math.Sqrt(gradX * gradX + gradY * gradY);
                    gradientData[y * width + x] = (byte)(gradientMagnitude > 128 ? 255 : 0);
                }
            });


            Parallel.For(0, height, y =>
            {
                for (int x = 0; x < width; x++)
                {
                    int pixelIndex = (y * width + x) * 4;
                    byte edge = gradientData[y * width + x];
                    pixelData[pixelIndex] = edge;
                    pixelData[pixelIndex + 1] = edge;
                    pixelData[pixelIndex + 2] = edge;
                }
            });

            // 최종 처리 시간 계산
            var totalElapsedTime = DateTime.Now - startTime;

            // UI 스레드에서 픽셀 데이터를 다시 씀
            Application.Current.Dispatcher.Invoke(() =>
            {
                writeableBitmap.Lock();
                writeableBitmap.WritePixels(new Int32Rect(0, 0, width, height), pixelData, width * 4, 0);
                writeableBitmap.Unlock();

                ProcessTimeTextBlock.Text = $"캐니엣지 처리 시간: {totalElapsedTime.TotalSeconds:F2}초";
            });
        }

        private async void YoloV5_Click(object sender, RoutedEventArgs e)
        {
            if (ImageView.Source is WriteableBitmap writeableBitmap)
            {
                try
                {
                    // 처리중 보이기
                    LoadingPanel.Visibility = Visibility.Visible;

                    WriteableBitmap writeableBitmap1 = null;
                    int width = 0, height = 0;

                    // UI 스레드에서 WriteableBitmap 생성 및 크기 가져오기
                    Application.Current.Dispatcher.Invoke(() =>
                    {
                        writeableBitmap1 = new WriteableBitmap(writeableBitmap);
                        width = writeableBitmap.PixelWidth;
                        height = writeableBitmap.PixelHeight;
                    });


                    if (writeableBitmap1 == null || width == 0 || height == 0)
                        throw new InvalidOperationException("WriteableBitmap이 유효하지 않습니다.");

                    // 시작 시간 기록
                    var startTime = DateTime.Now;

                    await Task.Run(() => ProcessYoloV5Async(writeableBitmap1, width, height, startTime));

                    // UI 스레드에서 WriteableBitmap 업데이트
                    Application.Current.Dispatcher.Invoke(() =>
                    {
                        writeableBitmap1.Freeze();
                        ImageView.Source = writeableBitmap1;
                    });
                }
                catch (Exception ex)
                {
                    MessageBox.Show($"욜로v5검출 중 오류가 발생했습니다: {ex.Message}",
                        "오류", MessageBoxButton.OK, MessageBoxImage.Error);
                }
                finally
                {
                    // 처리중 숨기기
                    LoadingPanel.Visibility = Visibility.Collapsed;

                    // 그레이스케일 버튼 비활성화
                    GrayScaleButton.IsEnabled = false;
                    // 캐니엣지 버튼 비활성화
                    CannyEdgeButton.IsEnabled = false;
                    // 욜로v5 버튼 활성화
                    YoloV5Button.IsEnabled = false;
                }
            }
            else
            {
                MessageBox.Show("그레이스케일 이미지가 필요합니다.", "오류", MessageBoxButton.OK, MessageBoxImage.Error);
            }
        }

        private void ProcessYoloV5Async(WriteableBitmap writeableBitmap, int width, int height, DateTime startTime)
        {
            var pythonScriptPath = @"C:\yolov5result\yolov5_inference.py";
            var inputImagePath = "yolov5_input_image.png";
            var outputImagePath = "yolov5_output_image.png";

            var pixelData = new byte[width * height * 4];

            // UI 스레드에서 픽셀 데이터를 복사
            Application.Current.Dispatcher.Invoke(() =>
            {
                writeableBitmap.CopyPixels(pixelData, width * 4, 0);
            });

            // 픽셀데이터를 이미지로 저장
            SaveBitmapToPng(writeableBitmap, inputImagePath);

            // Yolov5 검출 로직
            var processStartInfo = new ProcessStartInfo
            {
                FileName = "python",
                Arguments = $"\"{pythonScriptPath}\" \"{inputImagePath}\" \"{outputImagePath}\"",
                CreateNoWindow = true,
                UseShellExecute = false
            };

            using (var process = Process.Start(processStartInfo))
            {
                process.WaitForExit(); // Python 스크립트 실행이 완료될 때까지 대기
            }

            // 출력 이미지 픽셀 데이터로 변환
            byte[] outputPixelData = LoadPngToPixels(outputImagePath, out width, out height);

            // 최종 처리 시간 계산
            var totalElapsedTime = DateTime.Now - startTime;

            // UI 스레드에서 픽셀 데이터를 다시 씀
            Application.Current.Dispatcher.Invoke(() =>
            {
                writeableBitmap.Lock();
                writeableBitmap.WritePixels(new Int32Rect(0, 0, width, height), outputPixelData, width * 4, 0);
                writeableBitmap.Unlock();

                ProcessTimeTextBlock.Text = $"욜로v5객체감지 처리 시간: {totalElapsedTime.TotalSeconds:F2}초";
            });
        }

        // 이미지 파일로 저장하는 함수
        private void SaveBitmapToPng(WriteableBitmap writeableBitmap, string filePath)
        {
            if (writeableBitmap == null)
                throw new ArgumentNullException(nameof(writeableBitmap), "WriteableBitmap이 null입니다.");

            BitmapSource clonedBitmap = null;

            // UI 스레드에서 Bitmap을 복사하고 Freeze() 호출
            Application.Current.Dispatcher.Invoke(() =>
            {
                var renderTarget = new RenderTargetBitmap(
                    writeableBitmap.PixelWidth, writeableBitmap.PixelHeight,
                    96, 96, PixelFormats.Pbgra32);

                var visual = new DrawingVisual();
                using (var context = visual.RenderOpen())
                {
                    context.DrawImage(writeableBitmap, new Rect(0, 0, writeableBitmap.PixelWidth, writeableBitmap.PixelHeight));
                }
                renderTarget.Render(visual);

                clonedBitmap = renderTarget;
                clonedBitmap.Freeze(); // 반드시 UI 스레드에서 호출해야 오류 없음
            });

            using (var stream = new FileStream(filePath, FileMode.Create))
            {
                var encoder = new PngBitmapEncoder();
                encoder.Frames.Add(BitmapFrame.Create(clonedBitmap));
                encoder.Save(stream);
            }
        }



        // 이미지 파일을 로드하여 픽셀 데이터를 반환하는 함수
        private byte[] LoadPngToPixels(string filePath, out int width, out int height)
        {
            try
            {
                if (!File.Exists(filePath))
                {
                    MessageBox.Show($"파일을 찾을 수 없습니다: {filePath}");
                    width = height = 0;
                    return null;
                }

                // PNG 파일이 완전히 저장될 때까지 대기
                WaitForFile(filePath);

                var bitmapImage = new BitmapImage();
                bitmapImage.BeginInit();
                bitmapImage.UriSource = new Uri(filePath, UriKind.Absolute);
                bitmapImage.CacheOption = BitmapCacheOption.OnLoad; // 즉시 로드하여 파일 잠김 방지
                bitmapImage.CreateOptions = BitmapCreateOptions.IgnoreImageCache; // 이미지 캐시 무시
                bitmapImage.EndInit();
                bitmapImage.Freeze(); // 스레드 안전 처리

                WriteableBitmap writeableBitmap = null;

                // UI 스레드에서 WriteableBitmap 생성
                Application.Current.Dispatcher.Invoke(() =>
                {
                    writeableBitmap = new WriteableBitmap(bitmapImage);
                });

                width = writeableBitmap.PixelWidth;
                height = writeableBitmap.PixelHeight;

                var pixels = new byte[width * height * 4];

                // 픽셀 데이터 추출
                writeableBitmap.CopyPixels(pixels, width * 4, 0);

                return pixels;
            }
            catch (Exception ex)
            {
                MessageBox.Show($"PNG 로드 실패: {ex.Message}");
                width = height = 0;
                return null;
            }
        }

        // 파일이 완전히 저장될 때까지 대기하는 함수
        private void WaitForFile(string filePath)
        {
            int retryCount = 0;
            while (retryCount < 5)
            {
                try
                {
                    using (var stream = new FileStream(filePath, FileMode.Open, FileAccess.Read, FileShare.None))
                    {
                        return; // 파일을 성공적으로 열면 종료
                    }
                }
                catch (IOException)
                {
                    Thread.Sleep(200); // 200ms 대기 후 재시도
                    retryCount++;
                }
            }
        }

    }
}

cuda version
c:\>nvidia-smi
Thu Jan 30 20:05:58 2025
+-----------------------------------------------------------------------------------------+
| NVIDIA-SMI 566.14                 Driver Version: 566.14         CUDA Version: 12.7     |
|-----------------------------------------+------------------------+----------------------+
| GPU  Name                  Driver-Model | Bus-Id          Disp.A | Volatile Uncorr. ECC |
| Fan  Temp   Perf          Pwr:Usage/Cap |           Memory-Usage | GPU-Util  Compute M. |
|                                         |                        |               MIG M. |
|=========================================+========================+======================|
|   0  NVIDIA GeForce RTX 4060 ...  WDDM  |   00000000:01:00.0 Off |                  N/A |
| N/A   45C    P8              2W /   85W |       1MiB /   8188MiB |      0%      Default |
|                                         |                        |                  N/A |
+-----------------------------------------+------------------------+----------------------+

+-----------------------------------------------------------------------------------------+
| Processes:                                                                              |
|  GPU   GI   CI        PID   Type   Process name                              GPU Memory |
|        ID   ID                                                               Usage      |
|=========================================================================================|
|  No running processes found                                                             |
+-----------------------------------------------------------------------------------------+

NVIDIA 드라이버 버전	566.14
CUDA 버전	12.7
GPU 모델	NVIDIA GeForce RTX 4060
GPU 메모리	8GB (8188MiB)

torch 버전
c:\>python -c "import torch; print(torch.__version__)"
2.6.0+cpu
=> GPU 지원 버전의 PyTorch 설치
c:\>pip uninstall torch
c:\>pip install torch==2.6.0+cu118 --extra-index-url https://download.pytorch.org/whl/cu118
c:\>python -c "import torch; print(torch.__version__); print(torch.cuda.is_available()); print(torch.cuda.current_device()); print(torch.cuda.get_device_name(torch.cuda.current_device()))"
2.6.0+cu118
True
0
NVIDIA GeForce RTX 4060 Laptop GPU

ultralytics 버전
c:\>python -c "import ultralytics; print(ultralytics.__version__)"
8.3.69

c:\>python --version
Python 3.13.0

yolov5설치 및 업그레이드
c:\>git clone https://github.com/ultralytics/yolov5.git
c:\>cd yolov5
c:\yolov5>pip install -U -r requirements.txt
c:\yolov5>python.exe -m pip install --upgrade pip
c:\yolov5>pip install --upgrade ultralytics
c:\yolov5>pip install --upgrade torch

테스트
C:\wpfProject\WpfApp2\WpfApp2\bin\Debug\net8.0-windows>python "C:\yolov5result\yolov5_inference.py" --source "C:\yolov5\yolov5_input_image.png" --output "C:\yolov5\yolov5_output_image.png"    

오류
C:\wpfProject\WpfApp2\WpfApp2\bin\Debug\net8.0-windows>python "C:\yolov5result\yolov5_inference.py" --source "C:\yolov5\yolov5_input_image.png" --output "C:\yolov5\yolov5_output_image.png"
Traceback (most recent call last):
  File "C:\yolov5result\yolov5_inference.py", line 24, in <module>
    run_inference(args.source, args.output)
    ~~~~~~~~~~~~~^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\yolov5result\yolov5_inference.py", line 10, in run_inference
    results = model.predict(source)  # predict로 변경, verbose 인자 제거
  File "C:\Users\nayou\AppData\Local\Programs\Python\Python313\Lib\site-packages\ultralytics\engine\model.py", line 551, in predict
    self.predictor.setup_model(model=self.model, verbose=is_cli)
    ~~~~~~~~~~~~~~~~~~~~~~~~~~^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Users\nayou\AppData\Local\Programs\Python\Python313\Lib\site-packages\ultralytics\engine\predictor.py", line 310, in setup_model
    self.model = AutoBackend(
                 ~~~~~~~~~~~^
        weights=model or self.args.model,
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    ...<6 lines>...
        verbose=verbose,
        ^^^^^^^^^^^^^^^^
    )
    ^
  File "C:\Users\nayou\AppData\Local\Programs\Python\Python313\Lib\site-packages\torch\utils\_contextlib.py", line 116, in decorate_context
    return func(*args, **kwargs)
  File "C:\Users\nayou\AppData\Local\Programs\Python\Python313\Lib\site-packages\ultralytics\nn\autobackend.py", line 152, in __init__
    model = model.fuse(verbose=verbose)
TypeError: BaseModel.fuse() got an unexpected keyword argument 'verbose'

=> PyTorch 및 ultralytics와 같은 딥러닝 관련 라이브러리들은 Python 3.8 또는 Python 3.9 python 3.9버전으로 설치하는 것이 안정적
python 3.13.0 제어판 > 프로그림 및 기능 > 제거
python 3.9 다운로드 후 설치(https://www.python.org/downloads/release/python-390/)
Windows x86 executable installer	Windows     python-3.9.0.exe

시스템 환경 변수 설정
시스템환경변수편집 > 고급 > 환경변수 > 시스템 변수 > 
PYTHONPATH : C:\Users\nayou\AppData\Local\Programs\Python\Python39-32;C:\Users\nayou\AppData\Local\Programs\Python\Python39-32\Scripts
Path : %PYTHONPATH%;...

파이썬 버전 확인
c:\>python --version
Python 3.9.0

욜로설치
c:\yolov5>pip install -r requrements.txt

pip 최신 버전 설치
c:\yolov5>c:\users\nayou\appdata\local\programs\python\python39-32\python.exe -m pip install --upgrade pip
Collecting pip

numpy 설치
c:\>pip install numpy
c:\>pip install numpy
Requirement already satisfied: numpy in c:\users\nayou\appdata\local\programs\python\python39-32\lib\site-packages (2.0.2)

scipy 설치
c:\>pip install scipy

SciPy 1.15.1 설치
https://github.com/scipy/scipy/releases
scipy-1.15.1.tar.gz   56.7 MB
